#!/bin/python3

import random
from urllib.request import urlopen, Request
import re
import os

data_path = "chapters/"

def idgen(strings: str, length: int) -> str:
	res = ""

	for _ in range(length):
		res += random.choice(strings)

	return res

def img_download(url: str, file_path: str):
	headers = Request(url, headers={"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)"})
	img_binary = urlopen(headers).read()

	with open(file_path, "wb") as image:
		image.write(img_binary)

def get_req_res(url: str) -> str:
	request_obj = Request(url, headers={'User-Agent': 'xd this is fake. fix your auth. btw thank you for the website :D. from hithere'}) # Fake headers
	return urlopen(request_obj).read().decode()

def gen_html(url_s, chapters: list, chpt_name: str, dl: bool) -> None:

	pretty_imgs = ""

	if len(chapters) == 1: chapter = "{0}".format(chapters[0])
	else: chapter = "{0}_{1}".format(chapters[0], chapters[1])

	if type(url_s) == list:

		clean_src = []

		for x in url_s:
			url_res = get_req_res(x)
			dirty_srcs = re.findall('src="[^"]*"', url_res)
			clean_src += dirty_srcs[4:-3]

	else:
		url_resp_res = get_req_res(url_s)
		dirty_srcs = re.findall('src="[^"]*"', url_resp_res)
		clean_src = dirty_srcs[4:-3]

	del(dirty_srcs)

	if len(clean_src) == 0:
		print("\033[1;31mChapter is empty. Please wait until the chapter is released\033[0m")
		quit()

	if dl is True:
		file_locs = []
		img_cdns = [re.sub('src=|"', '', x) for x in clean_src]

		for x in img_cdns:
			img_id = idgen("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", 11)
			loc = "{0}scans/{1}-{2}".format(data_path, img_id, os.path.basename(x))
			file_locs.append(loc)
			img_download(x, loc)

		cool_stuff = [re.sub('src="[^"]*"', 'src="{0}"'.format(file_locs[x]), clean_src[x]) for x in range(len(clean_src))]
		del(clean_src)

	else: cool_stuff = clean_src; del(clean_src)

	for x in cool_stuff: pretty_imgs += '<img {0} alt="Image not loading. Please refresh your page">\n'.format(x)

	with open("{0}chc_{1}.html".format(data_path, chapter), "w") as file:
		file.write("""<!DOCTYPE html>
<html>

	<head>
		<title>{0}</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<style type="text/css">body {{ background-color: #3B3A39; }}</style>
	</head>

	<body>
{1}
	</body>

</html>
""".format(chpt_name, pretty_imgs))

soup_base = "https://w3.komisanwamanga.com"
counter = 0
check_inp = False
select_scr = ""

home_page = get_req_res(soup_base)

chpt_links = re.findall('"{0}/manga/.*/"'.format(soup_base), home_page)[-6::-1]
chpt_links.pop(len(chpt_links)-1)
clchpt_links = [x.replace('\"', '') for x in chpt_links]
del(chpt_links)

dname_links = re.findall('<a href="{0}/manga/.*/">.*<'.format(soup_base), home_page)
cname_links = [re.sub('<a href=".*">|</a><', '', x) for x in dname_links][-6::-1]
title_link = [[y, cname_links[x].replace("&#8217;", "'").replace("&#8211;", "â€“").replace("&#038;", "&")] for x, y in enumerate(clchpt_links)]

for y in title_link:
	counter += 1
	select_scr += "\033[1;34m[{0}] \033[1;36m{1}\033[0m\n".format(counter, y[1])

print(select_scr)
print("\033[1;33mTo download specific range of chapters (choices), use this format 'start_chapter end_chapter'. Example: 47 55\033[0m")

while check_inp == False:

	try:
		raw_chapter = input("\033[1;35m\nPlease choose the chapter [1-{0}]: \033[0m".format(counter)).strip(" 	\n")
		cook_chapter = [int(x) for x in raw_chapter.split()]

		if len(cook_chapter) == 1:
			if cook_chapter[0] > counter or cook_chapter[0] < 1:
				print("\033[1;31m\nThere is no the {0}th chapter\033[0m".format(cook_chapter[0]))
				continue

			check_inp = True

		elif len(cook_chapter) == 2:
			if cook_chapter[0] > cook_chapter[1]:
				print("\033[1;31m\nStart chapter cannnot have bigger value than the end chapter\033[0m")
				continue

			elif any(x > counter or x < 1 for x in cook_chapter):
				print("\033[1;31m\nChapter out of range\033[0m")
				continue

			check_inp = True

		else:
			print("\033[1;31m\nInvalid input format\033[0m")
			continue

	except ValueError:
		print("\033[1;31m\nPlease input valid number\033[0m")
		continue

check_inp = False

while check_inp == False:
	dl_or_st = input("\033[1;35m\nDo you want to make the HTML page available in offline mode ? (this will result in longer generating times) [y/n]: \033[0m").lower()

	if dl_or_st == 'y': check_inp = True
	elif dl_or_st == 'n': check_inp = True
	else: print("\033[1;31m\nNo such option exist\033[0m"); continue

if len(cook_chapter) == 1:

		gen_html(title_link[cook_chapter[0]-1][0], str(cook_chapter[0]).split(), title_link[cook_chapter[0]-1][1], dl_or_st == 'y')
		print("\033[1;32m\nHTML page generated\nLocation: '{0}chc_{1}.html'\033[0m".format(data_path, cook_chapter[0]))
		filename = "chc_{0}.html".format(cook_chapter[0])

elif len(cook_chapter) == 2:

	check_inp = False

	while check_inp == False:
		merge = input("\033[1;35m\nMerge chapters to a single file ? [y/n]: \033[0m")

		if merge.lower() == 'n':

			for i in range(cook_chapter[0], cook_chapter[1]+1):
				gen_html(title_link[i-1][0], str(i).split(), title_link[i-1][1], dl_or_st == 'y')
				print("\033[1;32m\nHTML page generated\nLocation: '{0}chc_{1}.html\033[0m'".format(data_path, i))

			filename = "chc_{0}.html".format(i)
			check_inp = True

		elif merge.lower() == 'y':

			usr_chp_lnks = []

			for i in range(cook_chapter[0], cook_chapter[1]+1):
				usr_chp_lnks.append(title_link[i-1][0])

			print("\033[1;33m\nThis may take a while. Please wait until its completed\033[0m")
			gen_html(usr_chp_lnks, cook_chapter, "Komi-san wa Chapter {0}-{1}".format(cook_chapter[0], cook_chapter[1]), dl_or_st == 'y')
			print("\033[1;32m\nHTML page have been generated\nLocation: '{0}chc_{1}_{2}.html'\033[0m".format(data_path, cook_chapter[0], cook_chapter[1]))

			filename = "chc_{0}_{1}.html".format(cook_chapter[0], cook_chapter[1])
			check_inp = True

		else:
			print("\033[1;31m\nNo such option\033[0m")
			continue
